<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BoysheO.Extensions</name>
    </assembly>
    <members>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.Collections.Generic.IEnumerable{System.Byte},System.Text.StringBuilder)">
            <summary>
            Get Hex string from bytes like "A1 BE C1".
            </summary>
            <param name="bytes">The collection of bytes to be converted to a hex string.</param>
            <param name="usingStringBuilder">Optional StringBuilder for improved performance by reducing allocations.</param>
            <returns>A string representing the hex values of the bytes.</returns>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.Collections.Generic.IList{System.Byte})">
            <summary>
                Get Hex string from bytes like "A1 BE C1".
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.Byte)">
            <summary>
                Get Hex string from byte like "A1","0F".<br />
                *Performance tips:it's same to call ToString("X2").
                If call in loop,suggestion is use <see cref="M:BoysheO.Util.ByteUtil.ByteToHexChar(System.Byte,System.Span{System.Char})"/> instead 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.ReadOnlySpan{System.Byte})">
            <summary>
                Get Hex string from bytes like "A1 BE C1".
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.Byte[])">
            <summary>
                Get Hex string from bytes like "A1 BE C1".
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToHexText(System.ArraySegment{System.Byte})">
            <summary>
                Get Hex string from bytes like "A1 BE C1".
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToBinText(System.ReadOnlySpan{System.Byte})">
            <summary>
                Get binText from byteSpan.ex."01001"
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToBinText(System.Byte)">
            <summary>
                Get binText from a byte.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.ToReverseArray(System.ReadOnlySpan{System.Byte})">
            <summary>
                Copy the span to a new Array reversed.<br />
                *Performance tips:If you don't need to get a new ary,use <see cref="M:System.Array.Reverse(System.Array)"/> better.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ByteExtensions.AsMemoryByteSpan``1(``0@)">
            <summary>
                Look through the value as bytes in memory.<br />
                *<b>UNSAFE</b>:Changing the return value causes the parameter value changed.
                If you change the string,the program maybe crash.The suggestion
                is use this for debug only.And,I don't promise the return value
                is same in different hardware environment.Only the base value
                can be the parameters.<br />
                将该值类型转换成内存中byte表示，无复制,仅限基础类型，否则会异常.
                *不安全：修改返回的span数组会修改初始值.在不清楚自己在做什么的时候不要修改返回值
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.Is0to9(System.Char)">
            <summary>
            Determine the char is in '0'-'9' without culture.<br />
            It's not same as <see cref="M:System.Char.IsDigit(System.Char)"/>.
            <see cref="M:System.Char.IsDigit(System.Char)"/>has more logic.
            *Performance tips:very fast in net48,but fail to against char.IsDigital() in net6.0 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.To0To9(System.Char)">
            <summary>
            Convert '0'-'9' to byte 0-9
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.Isatoz(System.Char)">
            <summary>
            Determine the char is in 'a'-'z' without culture.<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.IsAtoZ(System.Char)">
            <summary>
            Determine the char is in 'A'-'Z' without culture.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.IsEnglishLetter(System.Char)">
            <summary>
            Determine the char is in [a-zA-Z] without culture.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.ToUpper(System.Char)">
            <summary>
            Convert [a-zA-Z] to [A-Z]
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.ToLower(System.Char)">
            <summary>
            Convert [a-zA-Z] to [a-z]
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharExtensions.CovertAZazTo26(System.Char)">
            <summary>
            Convert char[a-zA-Z] to [1,26]<br />
            It's useful for convert Excel col number ABC.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.ParseToPositiveInt(System.ReadOnlySpan{System.Char})">
            <summary>
            Convert chars '123' to int 123.<br />
            <b>*UNSAFE</b>:make sure chars is all digit char.Not '-123' '12.3'<br />
            This method is faster than <see cref="M:System.Int32.Parse(System.String)"/> 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.SplitAsIntPoolArray(System.ReadOnlySpan{System.Char},System.Int32,System.Int32[]@)">
            <summary>
            Identifies numbers in string.<br />
            The char not number and + - will be dealt as separator<br />
            NOT SUPPORT any calculations in string<br />
            ex."a123b46.21+45-87"=>{123,46,21,45,-87}
            </summary>
            <param name="chars">source</param>
            <param name="initBuffSize">any value in [1,+).</param>
            <param name="ints">result</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">initBuffSize not in [1,+) or any math value in chars too big</exception>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.ParseToPositiveLong(System.ReadOnlySpan{System.Char})">
            <summary>
            Convert chars "123" to long 123<br />
            <b>*UNSAFE</b>:make sure chars is all digit char.Not '-123' '12.3'<br />
            This method is faster than <see cref="M:System.Int64.Parse(System.String)"/> 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.ToNewString(System.ReadOnlySpan{System.Char})">
            <summary>
            Creates a string from characters.
            You should use <see cref="M:System.ReadOnlySpan`1.ToString"/> for most cases.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.SkipCount(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Slice the source.
            ex."HelloWorld".SkipCount("Hello") => "World"
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.CharSpanExtensions.SkipTailCount(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Slice the source.
            ex."HelloWorld".SkipLastCount("World") => "Hello"
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.GetLastMonday0AM(System.DateTimeOffset)">
            <summary>
            Get last Monday 0 AM.If v is Monday 0 am,return itself.<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.GetCurWeekDay0AM(System.DateTimeOffset,System.DayOfWeek)">
            <summary>
            Calculate the week day 0 am current week.<br />
            *Base on ISO 8601,week starts from Monday.It's very important.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.GetCurDay0Am(System.DateTimeOffset)">
            <summary>
            Get current day 0 am.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.GetNextDay0Am(System.DateTimeOffset)">
            <summary>
            Get next day 0 am.
            到下一天凌晨时间 （上午12点，也就是0点）
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.GetCurHour0(System.DateTimeOffset)">
            <summary>
            Get current hour 0min0sec.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.IsExpire(System.DateTimeOffset,System.DateTimeOffset)">
            <summary>
            Is the time is after now.<br />
            Useful to reduce mistake and make the code reading comfortable. 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DateTimeOffsetExtensions.IsExpire(System.DateTimeOffset)">
            <summary>
            Is the time is after <see cref="P:System.DateTimeOffset.Now"/>.<br />
            Useful to reduce mistake and make the code reading comfortable. 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.DoubleExtension.CeilToInt(System.Double)">
            <summary>
                Returns the smallest integer greater to or equal to f.<br />
                ex. 1.2f=>2
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.EnumerableExtensions.IsSupersetOf``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether <paramref name="source"/> is a superset of <paramref name="another"/> or if both collections are equal.
            </summary>
            <remarks>
            Performance tips:
            This method uses LINQ. The <paramref name="source"/> collection will be converted to a set immediately.
            The <paramref name="another"/> collection may be fully traversed.
            </remarks>
            <typeparam name="T">The type of elements in the collections.</typeparam>
            <param name="source">The collection to check against.</param>
            <param name="another">The collection to check for inclusion in <paramref name="source"/>.</param>
            <returns>
            <c>true</c> if <paramref name="source"/> is a superset of all elements of <paramref name="another"/> or if both collections are equal; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BoysheO.Extensions.EnumerableExtensions.CopyTo``1(System.Collections.Generic.IEnumerable{``0},System.Span{``0})">
            <summary>
            Read elements in arg:source and write to arg:span until arg:span or arg:source end.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.EnumerableExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <summary>
            Find the element and return index.<br />
            return -1 if not found.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.EnumerableExtensions.TryPop``1(System.Collections.Generic.IReadOnlyList{``0},``0@)">
            <summary>
            use list as stack
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.EnumerableExtensions.Push``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            use list as stack
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.EnumExtensions.AsInt``1(``0)">
            <summary>
            Converts an enum to an int in a straightforward manner.
            *Note: If the enum's underlying type exceeds the range of int (e.g., long), 
            the result will be incorrect and no warning will be given.
            This API is designed based on the expectation that it will be heavily used, 
            while enums with long or ulong as their underlying types are rare. 
            This consideration led to the implementation of this API.<br/>
            简易枚举转int。
            *如果具体的枚举实现范围超过int，例如long，那么结果将会错误且没有提示
            可以预料这个API会被大量使用，而long、ulong作为枚举值的情形少之又少，基于此考量编写了此API
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.FloatExtension.CeilToInt(System.Single)">
            <summary>
                Returns the smallest integer greater to or equal to f.
                ex. 1.2f=>2
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.PositiveIntegerToEachDigit(System.Int32,System.Span{System.Int32})">
            <summary>
            Split int 123=>0,0,0,0,0,0,0,1,2,3
            </summary>
            <param name="value">source</param>
            <param name="buffer">buffer len must be 10</param>
            <returns>count of bytes write</returns>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsValidIndex``1(System.Int32,System.Collections.Generic.ICollection{``0})">
            <summary>
            value &gt; 0 &amp;&amp; value &lt; collection.Count
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int32,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int64,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Double,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Single,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt32,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.UInt16,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Int16,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Byte,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Int32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Int64)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Double)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Single)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.UInt32)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.UInt16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Int16)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Byte)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.IntExtensions.IsInRange(System.Int32,System.Decimal,System.Decimal)">
            <summary>
            Is same to value &lt;= minInclusive &amp;&amp; value &gt; = maxInclusive
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.MemoryExtensions.Panning``1(System.Span{``0},System.Int32,System.Func{System.Int32,``0})">
            <summary>
                Move every elements in arg:span to left side.<br />
                ex.int{1,2,3,4,5}.Panning(1) => int{2,3,4,5,0}<br />
                ex.int{1,2,3,4,5}.Panning(-1) => int{0,1,2,3,4}<br />
            </summary>
            <exception cref="T:System.ArgumentException">count not be 0</exception>
        </member>
        <member name="M:BoysheO.Extensions.ObjectExtensions.WarpToArray``1(``0)">
            <summary>
                Warp an element to an array.<br />
                The method is designed not to break the chained API
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.ObjectExtensions.GetDescription(System.Enum)">
            <summary>
                Get <see cref="P:System.ComponentModel.DescriptionAttribute.Description" /> by reflection.<br />
                * Emphasize that in practice, it has been found that GetCustomAttribute() is often stripped by Unity's IL2CPP.
                If you are using it in Unity, you must ensure that this function is used somewhere in the IL2CPP code.<br />
                * 重点强调，在实践中发现GetCustomAttribute()经常会被Unity IL2CPP裁剪，如果在Unity中使用，必须保证在IL2CPP代码中有使用过此函数。<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.PathValueExtensions.CreatDirectoryIfNotExist(BoysheO.Toolkit.PathValue)">
            <summary>
            If directory not exist,creat it.
            </summary>
            <param name="directory">Directory path.</param>
        </member>
        <member name="M:BoysheO.Extensions.PathValueExtensions.WriteAllBytes(BoysheO.Toolkit.PathValue,System.Byte[])">
            <summary>
            Creat directory if not exist and write file.
            </summary>
            <param name="filePath">file</param>
        </member>
        <member name="M:BoysheO.Extensions.StreamExtensions.GetAllBytesFromOffset0(System.IO.Stream)">
            <summary>
            Seek to 0 and read all bytes.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.JoinAsOneString(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
                Same to string.Join
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.RemoveSpaces(System.String)">
            <summary>
                return new string without any space
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.IsMatch(System.String,System.String)">
            <summary>
                调用<see cref="M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)" />验证,op=
                <see cref="F:System.Text.RegularExpressions.RegexOptions.CultureInvariant" />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.IsMatch(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
                调用regex验证
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ToRawBytes(System.String,System.Boolean)">
            <summary>
                Put every chars to bytes array.<br />
                ex."123".ToRawBytes() => {31,32,33}
            </summary>
            <exception cref="T:System.InvalidCastException">any char in arg:srt out of byte</exception>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ToRawBytes(System.String,System.ArraySegment{System.Byte},System.Boolean)">
            <summary>
                Put every chars to bytes array.<br />
                *Performance tips:The method perform similarly to <see cref="M:BoysheO.Extensions.StringExtensions.ToRawBytes(System.String,System.Boolean)"/>
                ex."123".ToRawBytes() => {31,32,33}
            </summary>
            <exception cref="T:System.InvalidCastException">any char in arg:srt out of byte</exception>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ToRawBytes(System.String,System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
                Put every chars to bytes array.<br />
                *Performance tips:The method perform similarly to <see cref="M:BoysheO.Extensions.StringExtensions.ToRawBytes(System.String,System.Boolean)"/>
                ex."123".ToRawBytes() => {31,32,33}
            </summary>
            <exception cref="T:System.InvalidCastException">any char in arg:srt out of byte</exception>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ToRawString(System.ReadOnlySpan{System.Byte})">
            <summary>
                 Put every byte to char array as string<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.MemoryToString(System.ReadOnlySpan{System.Byte})">
            <summary>
                Convert the source as new string directly.<br />
                If the source is utf16,the method can return string readable. 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.MakeFirstCharUpperOrNot(System.String)">
            <summary>
            Make first char upper or not without culture<br />
            ex."abc"=>"Abc","ABC"=>"ABC"
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.MakeFirstCharLowerOrNot(System.String)">
            <summary>
            Make first char lower or not without culture<br />
            ex."abc"=>"abc","ABC"=>"aBC"
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ParseToInt(System.String)">
            <summary>
            Same as <see cref="M:System.Int32.Parse(System.String)"/><br />
            *Performance tips:If you can make sure string has number char only,
            you can use <see cref="M:BoysheO.Extensions.StringExtensions.ParseToPositiveInt(System.String)"/> 4 times faster.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ParseToPositiveInt(System.String)">
            <summary>
            Convert chars '123' to int 123.<br />
            <b>*UNSAFE</b>:make sure chars is all digit char.Not '-123' '12.3'<br />
            This method is faster than <see cref="M:System.Int32.Parse(System.String)"/> 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ParseToPositiveLong(System.String)">
            <summary>
            Convert chars "123" to long 123<br />
            <b>*UNSAFE</b>:make sure chars is all digit char.Not '-123' '12.3'<br />
            This method is faster than <see cref="M:System.Int64.Parse(System.String)"/> 
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.Format(System.String,System.Object)">
            <summary>
            Same as string.Format
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.Format(System.String,System.Object,System.Object)">
            <summary>
            Same as string.Format
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.Format(System.String,System.Object,System.Object,System.Object)">
            <summary>
            Same as string.Format
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.Format(System.String,System.Object[])">
            <summary>
            Same as string.Format
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.StringExtensions.ReplaceBackslash(System.String)">
            <summary>
            Same as str.Replace('\\','/');
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsClassAndImplement(System.Type,System.Type)">
            <summary>
                Determine the type is implement the another type (interface or class,GenericTypeDefinition not supported) and is class.<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsStructAndImplement(System.Type,System.Type)">
            <summary>
                Determine the type is implement the another type (interface or class,GenericTypeDefinition not supported) and is struct.<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsSealedAndImplement(System.Type,System.Type)">
            <summary>
                Determine the type is implement the another type (interface or class,GenericTypeDefinition not supported) and is sealed.<br />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsImplement(System.Type,System.Type)">
            <summary>
                Determine the type is implement the another type(interface or class,GenericTypeDefinition supported)
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsNumericType(System.Type)">
            <summary>
                Determine the type is int,double,long .. or other math type.
                No nullable type.
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.IsNullableType(System.Type)">
            <summary>
                Determine the type is <see cref="T:System.Nullable`1" />
            </summary>
        </member>
        <member name="M:BoysheO.Extensions.TypeExtensions.GetTypeCode(System.Type)">
            <summary>
            Get code string<br />
            ex.typeof(List&lt;int&gt;) => "List&lt;int&gt;"
            </summary>
        </member>
        <member name="T:BoysheO.Toolkit.PathValue">
            <summary>
            It means a file path or a directory path
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.Combine(BoysheO.Toolkit.PathValue)">
            <summary>
            Same as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>
            ex. "a/b" + "c.txt" -> "a/b/c.txt"
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.GetFileName">
            <summary>
            Same as <see cref="M:System.IO.Path.GetFileName(System.String)"/>
            ex. "a/b/c.txt" -> "c.txt"
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.GetDirectoryName">
            <summary>
            Same as <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/>
            ex. "a/b/c.txt" -> "a/b"
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.GetFileNameWithoutExt">
            <summary>
            Same as <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.String)"/>
            ex. "a.txt" -> "a"
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.GetExtension">
            <summary>
            Same as <see cref="M:System.IO.Path.GetExtension(System.String)"/>
            ex. "a.txt" -> ".txt"
            </summary>
            <returns></returns>
        </member>
        <member name="M:BoysheO.Toolkit.PathValue.ChangeExtension(System.String,System.String)">
            <summary>
            Same as <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            ex. a.txt -> a.bytes
            </summary>
        </member>
        <member name="T:BoysheO.Toolkit.SerializableRandom">
            <summary>
            Thread not safe
            Float and double maybe perform in different CPU.
            性能会比原生的弱点，因为原生的有针对平台优化。浮点数计算随CPU架构，所以使用时要留意
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.#ctor(BoysheO.Toolkit.SerializableRandom)">
            <summary>
            clone
            </summary>
        </member>
        <member name="P:BoysheO.Toolkit.SerializableRandom.Seed">
            <summary>
                The current seed of this instance.
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.Reset">
            <summary>
                Resets this instance using it's current seed.
                This means that the RNG will start over again,
                repeating the same values that it originally had.
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.Reseed">
            <summary>
                Reseeds this instance using a new GUID Hashcode
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.Reseed(System.Int32)">
            <summary>
                Reseeds this instance using a given integer seed.
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextInteger(System.Int32)">
            <summary>
                不含最大值
            </summary>
            <param name="maxExclusive"></param>
            <returns></returns>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDouble">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDoubles(System.Double[])">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDoubles(System.Int32)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDoubles(System.Double,System.Double,System.Double[])">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextDoubles(System.Double,System.Double,System.Int32)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloat">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloats(System.Single[])">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloats(System.Int32)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloat(System.Single,System.Single)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloats(System.Single,System.Single,System.Single[])">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SerializableRandom.NextFloats(System.Single,System.Single,System.Int32)">
            <summary>
            Notice:Not perform same in different CPU
            </summary>
        </member>
        <member name="T:BoysheO.Toolkit.SpanReaderB">
            <summary>
            按大端序读取数据
            *不会验证Seek是否越界，以获取更多性能。这应该是合理的
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SpanReaderB.ReadStringASCII">
            <summary>
            按'\0'识别字符串结尾，但是输出结果中不含'\0'
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:BoysheO.Toolkit.SpanReaderB.ReadBytesUntilNull">
            <summary>
            读取到下个/0标记，输出/0标记前的所有byte，并且Seek跳到/0符号后一个位置
            没有找到/0标记就会抛异常
            如果/0标记在第一个字符，则输出的Span会是长度0
            </summary>
            <returns></returns>
        </member>
        <member name="T:BoysheO.Toolkit.SpanWriterB">
            <summary>
            按大端序写入数据
            </summary>
        </member>
        <member name="M:BoysheO.Toolkit.SpanWriterB.WriteBytes(System.ReadOnlySpan{System.Byte})">
            <summary>
            只写入，不写入长度
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.HexCharToByte(System.Char)">
            <summary>
                将单个0-9A-Fa-f字符视作Hex转byte
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.HexCharToByte(System.Char,System.Char)">
            <summary>
                将形如"01""AF"这样的Hex字符对，转换成等义byte
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.ByteToHexChar(System.Byte,System.Span{System.Char})">
            <summary>
            Convert the byte as '0A','3F'...<br />
            buff's index 0 is the high digit.<br />
            Buff must be 2 len
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.ByteToBinDigits(System.Byte,System.Span{System.Boolean})">
            <summary>
            Convert the byte to bin numbers.ex.0A=>1010 (numbers' index 0 is 1) <br />
            true is 1,false is 0
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.IsGZipHeader(System.ReadOnlySpan{System.Byte})">
            <summary>
                判断前2个字节是否符合gzip标准1f8b<br />
                Get to know is the bytes start with 1f8b GZip header
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.IsGZipHeader(System.Span{System.Byte})">
            <summary>
                判断前2个字节是否符合gzip标准1f8b<br />
                Get to know is the bytes start with 1f8b GZip header
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.IsGZipHeader(System.Byte[])">
            <summary>
                判断前2个字节是否符合gzip标准1f8b<br />
                Get to know is the bytes start with 1f8b GZip header
            </summary>
        </member>
        <member name="M:BoysheO.Util.ByteUtil.IsGZipHeader(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
                判断前2个字节是否符合gzip标准1f8b<br />
                Get to know is the bytes start with 1f8b GZip header
            </summary>
        </member>
        <member name="M:BoysheO.Util.DebugUtil.GetCallerContext(System.String,System.String,System.Int32)">
            <summary>
                获取调用方信息
            </summary>
        </member>
        <member name="M:BoysheO.Util.DebugUtil.GetCallerFile(System.String)">
            <summary>
                获取调用方信息
            </summary>
        </member>
        <member name="M:BoysheO.Util.DebugUtil.GetCallerMemberName(System.String)">
            <summary>
                获取调用方信息
            </summary>
        </member>
        <member name="M:BoysheO.Util.IntUtil.ToStringWithSign(System.Int32,System.String)">
            <summary>
            输出形如+1、-1，+0这类带符号的;其中0值的显示取决于zero参数<br />
            </summary>
            <param name="value"></param>
            <param name="zero">当value为0时，输出这个值。建议值为"0"、"+0"、"-0"、" 0"之一</param>
            <returns></returns>
        </member>
        <member name="M:BoysheO.Util.IOUtil.SaveTextToFile(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Saves text content to the specified file path
            </summary>
            <param name="text">The text content to save</param>
            <param name="filePath">The target file path</param>
            <param name="createDirectoryIfNotExists">Whether to create directory if it doesn't exist</param>
            <param name="throwIfFileExists">Whether to throw exception if file already exists</param>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when directory doesn't exist and createDirectoryIfNotExists is false</exception>
            <exception cref="T:System.IO.IOException">Thrown when file exists and throwIfFileExists is true</exception>
        </member>
        <member name="M:BoysheO.Util.IOUtil.SaveBytesToFile(System.Byte[],System.String,System.Boolean,System.Boolean)">
            <summary>
            Saves byte array to the specified file path
            </summary>
            <param name="bytes">The byte array to save</param>
            <param name="filePath">The target file path</param>
            <param name="createDirectoryIfNotExists">Whether to create directory if it doesn't exist</param>
            <param name="throwIfFileExists">Whether to throw exception if file already exists</param>
            <exception cref="T:System.IO.DirectoryNotFoundException">Thrown when directory doesn't exist and createDirectoryIfNotExists is false</exception>
            <exception cref="T:System.IO.IOException">Thrown when file exists and throwIfFileExists is true</exception>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.ManhattanDistance(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                计算两坐标曼哈顿距离
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.ReadOnlySpan{``0})">
            <summary>
                等概率抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.Collections.Generic.IList{``0})">
            <summary>
                等概率抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.Collections.Generic.ICollection{System.ValueTuple{``0,System.UInt32}})">
            <summary>
                加权抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.ReadOnlySpan{System.ValueTuple{``0,System.UInt32}})">
            <summary>
                加权抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(``0[])">
            <summary>
                等概率抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.Span{``0})">
            <summary>
                等概率抽取1个元素
                collection必须可数
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.ValueTuple{``0,System.UInt32}[])">
            <summary>
                加权抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Draw``1(System.Span{System.ValueTuple{``0,System.UInt32}})">
            <summary>
                加权抽取1个元素
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.DrawAsPooledArray(System.Int32,System.Int32)">
            <summary>
                等概率抽取n个元素（排列）<br/>
                蓄水池算法<br/>
                *最终输出结果的顺序既有可能是顺序的，也有可能是乱序的
            </summary>
            <param name="count">抽取多少个元素</param>
            <param name="poolSize">奖池大小</param>
            <returns>池化数组，用完记得归还<see cref="T:System.Buffers.ArrayPool`1"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">参数不正确</exception>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.DrawAsPooledArraySorted(System.Int32,System.Int32)">
            <summary>
                等概率抽取n个元素（排列）<br/>
                蓄水池有序改良算法<br/>
                最终结果保持增序排列<br />
            </summary>
            <param name="count">抽取多少个元素</param>
            <param name="poolSize">奖池大小</param>
            <returns>池化数组，用完记得归还<see cref="T:System.Buffers.ArrayPool`1"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">参数不正确</exception>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Permutation``1(System.ValueTuple{System.UInt32,``0}[],System.UInt32)">
            <summary>
                加权抽取n个元素（排列）(非树）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Permutation``1(System.Collections.Generic.IList{System.ValueTuple{System.UInt32,``0}},System.UInt32)">
            <summary>
                加权抽取n个元素（排列）(非树）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Combination``1(``0[],System.UInt32)">
            <summary>
                等概率抽取抽取n个元素（组合）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Combination``1(System.Collections.Generic.IList{``0},System.UInt32)">
            <summary>
                等概率抽取抽取n个元素（组合）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Combination``1(System.ValueTuple{System.UInt32,``0}[],System.UInt32)">
            <summary>
                加权抽取n个元素（组合）(非树）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Combination``1(System.Collections.Generic.IList{System.ValueTuple{System.UInt32,``0}},System.UInt32)">
            <summary>
                加权抽取n个元素（组合）(非树）
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Combination(System.Int32,System.Int32)">
            <summary>
            从n中组合k个元素组合的组合数
            只能算很小的值
            很大的值考虑使用大数库
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Permutation(System.Int32,System.Int32)">
            <summary>
            计算P(n,k)，从n个里面抽取k个排列的排列数
            只能算很小的值(n∈[1,12],k∈[1,n])
            很大的值考虑使用大数库
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Factorial1(System.Int32)">
            <summary>
            提供基本款阶乘(只能计算1-12）
            很大的值考虑使用大数库
            </summary>
        </member>
        <member name="M:BoysheO.Util.MathLibrary.Factorial2(System.Int32)">
            <summary>
            提供基本款阶乘(只能计算1-20）
            很大的值考虑使用大数库
            </summary>
        </member>
        <member name="T:BoysheO.Util.RandomUtil">
            <summary>
                <see cref="T:System.Random" />的非线程安全的镜像API，便于切换
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.Resize``1(``0[]@,System.Int32,System.Int32,System.Buffers.ArrayPool{``0})">
            <summary>
            resize a buff from ArrayPool.Share with ArrayPool.Share
            !after resize,buff.Length is more than the size given generally
            !resize cause copy every time,so call it just need
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.Add``1(``0[]@,System.Int32@,``0,System.Buffers.ArrayPool{``0})">
            <summary>
            Add value to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.AddRange``1(``0[]@,System.Int32@,System.Collections.Generic.IReadOnlyList{``0},System.Buffers.ArrayPool{``0})">
            <summary>
            Add values to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.AddRange``1(``0[]@,System.Int32@,System.ReadOnlySpan{``0},System.Buffers.ArrayPool{``0})">
            <summary>
            Add values to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.Insert``1(``0[]@,System.Int32@,``0,System.Int32,System.Buffers.ArrayPool{``0})">
            <summary>
            Insert value to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.InsertRange``1(``0[]@,System.Int32@,System.ReadOnlySpan{``0},System.Int32,System.Buffers.ArrayPool{``0})">
            <summary>
            Insert value to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.RefArrayPoolUtil.InsertRange``1(``0[]@,System.Int32@,System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Buffers.ArrayPool{``0})">
            <summary>
            Insert value to the buff from ArrayPool.Share
            * resize automatically
            </summary>
        </member>
        <member name="M:BoysheO.Util.StringUtil.BytesToReadableSize(System.Int64)">
            <summary>
            1023=>1023b 1024=>1k 1048576=>1m
            </summary>
        </member>
        <member name="M:BoysheO.Util.StringUtil.BytesToReadableSize(System.UInt64)">
            <summary>
            Converts a byte count into a more readable size format.
            Example: 1023 => 1023b, 1024 => 1k, 1048576 => 1m.
            Notice:The size returned may not be precise
            </summary>
        </member>
        <member name="M:BoysheO.Util.UnsafeUtil.AsMemoryByteSpan``1(``0@)">
            <summary>
                Look through the value as bytes in memory.<br />
                *<b>UNSAFE</b>:Changing the return value causes the parameter value changed.
                If you change the string,the program maybe crash.The suggestion
                is use this for debug only.And,I don't promise the return value
                is same in different hardware environment.Only the base value
                can be the parameters.<br />
                将该值类型转换成内存中byte表示，无复制,仅限基础类型，否则会异常.
                *不安全：修改返回的span数组会修改初始值.在不清楚自己在做什么的时候不要修改返回值
            </summary>
        </member>
        <member name="M:DateAndTime.TimeUtil.GetCountOfTheTimeBetween(System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            计算一个每日时刻在一段时间中的出现次数<br />
            *起始时刻与timeMsOfDay重叠时算入出现次数，终止时刻与timeMsOfDay重叠时不算入出现次数<br />
            calculate the count of the time of day between start to end <br />
            *Result increase while starMs same as timeMsOfDay but endMs do not<br />
            *弃用：与Cron库计算结果不一致。函数实现有误或单元测试编写有误
            </summary>
            <param name="startMs">
            起始时间戳，需要保证起点为0点<br/>
            Start timestamp.The standards it used must start from 0am</param>
            <param name="endMs">
            终止时间戳，需要保证0时刻与startMs语义一致<br />
            End timestamp.The standards it used should be same as startMs. <br />
            </param>
            <param name="timeMsOfDay">
            每日时刻<br />
            Time in day<br />
            </param>
            <param name="timeOffset">
            时区，指明timeMsOfDay所表达的时区。毫秒<br />
            Timezone's timeoffset.Millsec.<br/>
            </param>
            <returns></returns>
        </member>
    </members>
</doc>
